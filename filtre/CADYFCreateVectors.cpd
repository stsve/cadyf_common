<CustomFilterDefinitions>
  <CustomProxyDefinition name="Create CADYF Vectors" group="filters">
    <CompoundSourceProxy id="23560" servers="1">
      <Proxy group="filters" type="ProgrammableFilter" id="18114" servers="1" compound_name="ProgrammableFilter1">
        <Property name="CopyArrays" id="18114.CopyArrays" number_of_elements="1">
          <Element index="0" value="0"/>
          <Domain name="bool" id="18114.CopyArrays.bool"/>
        </Property>
        <Property name="InformationScript" id="18114.InformationScript" number_of_elements="1">
          <Element index="0" value=""/>
        </Property>
        <Property name="Input" id="18114.Input" number_of_elements="1">
          <Domain name="groups" id="18114.Input.groups"/>
          <Domain name="input_type" id="18114.Input.input_type"/>
        </Property>
        <Property name="OutputDataSetType" id="18114.OutputDataSetType" number_of_elements="1">
          <Element index="0" value="8"/>
          <Domain name="enum" id="18114.OutputDataSetType.enum">
            <Entry value="8" text="Same as Input"/>
            <Entry value="0" text="vtkPolyData"/>
            <Entry value="2" text="vtkStructuredGrid"/>
            <Entry value="3" text="vtkRectilinearGrid"/>
            <Entry value="4" text="vtkUnstructuredGrid"/>
            <Entry value="6" text="vtkImageData"/>
            <Entry value="10" text="vtkUniformGrid"/>
            <Entry value="13" text="vtkMultiblockDataSet"/>
            <Entry value="15" text="vtkHierarchicalBoxDataSet"/>
            <Entry value="19" text="vtkTable"/>
            <Entry value="33" text="vtkMolecule"/>
          </Domain>
        </Property>
        <Property name="PythonPath" id="18114.PythonPath" number_of_elements="1">
          <Element index="0" value=""/>
        </Property>
        <Property name="Script" id="18114.Script" number_of_elements="1">
          <Element index="0" value="i = inputs[0]&#xa;o = output&#xa;&#xa;np = i.GetNumberOfPoints()&#xa;&#xa;varT = list(i.PointData.keys())&#xa;varT.sort()&#xa;varP = list(varT)&#xa;varC = list(i.CellData.keys())&#xa;&#xa;def gen_exa_names(l):&#xa;    return tuple([n + &#x22;EXA&#x22; for n in l[:-1]] + [l[-1] + &#x22;Exa&#x22;])&#xa;&#xa;def gen_grad_names(l):&#xa;    l2 = []&#xa;    for n in l[:-1]:&#xa;        l2 += [n + s for s in [&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;]]&#xa;    l2.append(&#x27;Gradient&#x27; + l[-1])&#xa;    return tuple(l2)&#xa;&#xa;def gen_hess_names(l):&#xa;    l2 = []&#xa;    for n in l[:-1]:&#xa;        lt = [n + s for s in [&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;]]&#xa;        for nn in lt:&#xa;            l2 += [nn + s for s in [&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;]]&#xa;    l2.append(&#x27;Hessian&#x27; + l[-1])&#xa;    return tuple(l2)&#xa;&#xa;def check_var(v,l):&#xa;    return v in l[:-1]&#xa;&#xa;def check_list_var(l,p,np=[]):&#xa;    return all([v in l for v in p]) and not any([v in l for v in np])&#xa;&#xa;def rename_var(nu,na):&#xa;    if check_list_var(varP,[nu]):&#xa;        a = vtk.vtkDoubleArray()&#xa;        a.SetNumberOfTuples(np)&#xa;        a.SetName(na)&#xa;        a.CopyComponent(0,i.PointData[nu].VTKObject,0)&#xa;        varP.remove(nu)&#xa;        o.PointData.VTKObject.AddArray(a)&#xa;&#xa;def create_vec(nu,nv,nw,na):&#xa;    a = vtk.vtkDoubleArray()&#xa;    a.SetNumberOfComponents(3)&#xa;    a.SetNumberOfTuples(np)&#xa;    a.SetName(na)&#xa;    for idx,nm in enumerate([&#x27;X&#x27;,&#x27;Y&#x27;,&#x27;Z&#x27;]):&#xa;        a.SetComponentName(idx,nm)&#xa;    if check_list_var(varP,[nu,nv]):&#xa;        # X, Y components&#xa;        for pos,vn in zip([0,1],[nu,nv]):&#xa;            a.CopyComponent(pos,i.PointData[vn].VTKObject,0)&#xa;            varP.remove(vn)&#xa;        # Z components&#xa;        if check_list_var(varP,[nw]):&#xa;            a.CopyComponent(2,i.PointData[nw].VTKObject,0)&#xa;            varP.remove(nw)&#xa;        else:&#xa;            a.FillComponent(2,0.0)&#xa;    elif check_list_var(varP,[nw],[nu,nv]):&#xa;        a.FillComponent(0,0.0)&#xa;        a.FillComponent(1,0.0)&#xa;        a.CopyComponent(2,i.PointData[nw].VTKObject,0)&#xa;        varP.remove(nw)&#xa;    else:&#xa;        return&#xa;    o.PointData.VTKObject.AddArray(a)&#xa;&#xa;def create_mat(nuu,nuv,nuw,nvu,nvv,nvw,nwu,nwv,nww,na):&#xa;    if check_list_var(varP,[nuu,nuv,nvu,nvv]):&#xa;        a = vtk.vtkDoubleArray()&#xa;        a.SetNumberOfComponents(9)&#xa;        a.SetNumberOfTuples(np)&#xa;        a.SetName(na)&#xa;        for idx,nm in enumerate([&#x27;XX&#x27;,&#x27;XY&#x27;,&#x27;XZ&#x27;,&#x27;YX&#x27;,&#x27;YY&#x27;,&#x27;YZ&#x27;,&#x27;ZX&#x27;,&#x27;ZY&#x27;,&#x27;ZZ&#x27;]):&#xa;            a.SetComponentName(idx,nm)&#xa;        # XX, XY, YX and YY components&#xa;        for pos,vn in zip([0,1,3,4],[nuu,nuv,nvu,nvv]):&#xa;            a.CopyComponent(pos,i.PointData[vn].VTKObject,0)&#xa;            varP.remove(vn)&#xa;        # Z* and *Z components&#xa;        for pos,vn in zip([2,5,6,7,8],[nuw,nvw,nwu,nwv,nww]):&#xa;            if check_list_var(varP,[vn]):&#xa;                a.CopyComponent(pos,i.PointData[vn].VTKObject,0)&#xa;                varP.remove(vn)&#xa;            else:&#xa;                a.FillComponent(pos,0.0)&#xa;        o.PointData.VTKObject.AddArray(a)&#xa;&#xa;def create_tens3(nuuu,nuuv,nuuw,nuvu,nuvv,nuvw,nuwu,nuwv,nuww,nvuu,nvuv,nvuw,nvvu,nvvv,nvvw,nvwu,nvwv,nvww,nwuu,nwuv,nwuw,nwvu,nwvv,nwvw,nwwu,nwwv,nwww,na):&#xa;    a = vtk.vtkDoubleArray()&#xa;    a.SetNumberOfComponents(27)&#xa;    a.SetNumberOfTuples(np)&#xa;    a.SetName(na)&#xa;    for idx,nm in enumerate([&#x27;XXX&#x27;,&#x27;XXY&#x27;,&#x27;XXZ&#x27;,&#x27;XYX&#x27;,&#x27;XYY&#x27;,&#x27;XYZ&#x27;,&#x27;XZX&#x27;,&#x27;XZY&#x27;,&#x27;XZZ&#x27;,&#x27;YXX&#x27;,&#x27;YXY&#x27;,&#x27;YXZ&#x27;,&#x27;YYX&#x27;,&#x27;YYY&#x27;,&#x27;YYZ&#x27;,&#x27;YZX&#x27;,&#x27;YZY&#x27;,&#x27;YZZ&#x27;,&#x27;ZXX&#x27;,&#x27;ZXY&#x27;,&#x27;ZXZ&#x27;,&#x27;ZYX&#x27;,&#x27;ZYY&#x27;,&#x27;ZYZ&#x27;,&#x27;ZZX&#x27;,&#x27;ZZY&#x27;,&#x27;ZZZ&#x27;]):&#xa;        a.SetComponentName(idx,nm)&#xa;    for pos,vn in zip(range(27),[nuuu,nuuv,nuuw,nuvu,nuvv,nuvw,nuwu,nuwv,nuww,nvuu,nvuv,nvuw,nvvu,nvvv,nvvw,nvwu,nvwv,nvww,nwuu,nwuv,nwuw,nwvu,nwvv,nwvw,nwwu,nwwv,nwww]):&#xa;        if check_list_var(varP,[vn]):&#xa;            a.CopyComponent(pos,i.PointData[vn].VTKObject,0)&#xa;            varP.remove(vn)&#xa;        else:&#xa;            a.FillComponent(pos,0.0)&#xa;    o.PointData.VTKObject.AddArray(a)&#xa;&#xa;MeshVelocity              = (&#x27;DXSIDT&#x27;,&#x27;DETADT&#x27;,&#x27;DZTADT&#x27;,&#x27;MeshVelocity&#x27;)&#xa;&#xa;ReactionForce             = (&#x27;LX&#x27;,&#x27;LY&#x27;,&#x27;LZ&#x27;,&#x27;ReactionForce&#x27;)&#xa;NormalHeatFlux            = (&#x27;LT&#x27;,&#x27;NormalHeatFlux&#x27;)&#xa;&#xa;Density                   = (&#x27;RHO&#x27;,&#x27;Density&#x27;)&#xa;SpeedSound                = (&#x27;A&#x27;,&#x27;SpeedSound&#x27;)&#xa;&#xa;Velocity                  = (&#x27;U&#x27;,&#x27;V&#x27;,&#x27;W&#x27;,&#x27;Velocity&#x27;)&#xa;VelocityExa               = gen_exa_names (Velocity)&#xa;GradientVelocity          = gen_grad_names(Velocity)&#xa;GradientVelocityExa       = gen_exa_names (GradientVelocity)&#xa;HessianVelocity           = gen_hess_names(Velocity)&#xa;HessianVelocityExa        = gen_exa_names (HessianVelocity)&#xa;&#xa;MeshDisp                  = (&#x27;XSI&#x27;,&#x27;ETA&#x27;,&#x27;ZTA&#x27;,&#x27;MeshDisp&#x27;)&#xa;MeshDispExa               = gen_exa_names (MeshDisp)&#xa;GradientMeshDisp          = gen_grad_names(MeshDisp)&#xa;GradientMeshDispExa       = gen_exa_names (GradientMeshDisp)&#xa;&#xa;Pressure                  = (&#x27;P&#x27;,&#x27;Pressure&#x27;)&#xa;PressureExa               = gen_exa_names (Pressure)&#xa;GradientPressure          = gen_grad_names(Pressure)&#xa;GradientPressureExa       = gen_exa_names (GradientPressure)&#xa;&#xa;Temperature               = (&#x27;T&#x27;,&#x27;Temperature&#x27;)&#xa;TemperatureExa            = gen_exa_names (Temperature)&#xa;GradientTemperature       = gen_grad_names(Temperature)&#xa;GradientTemperatureExa    = gen_exa_names (GradientTemperature)&#xa;&#xa;TurbulenceVar1            = (&#x27;K&#x27;,&#x27;TurbulenceVar1&#x27;)&#xa;TurbulenceVar1Exa         = gen_exa_names (TurbulenceVar1)&#xa;GradientTurbulenceVar1    = gen_grad_names(TurbulenceVar1)&#xa;GradientTurbulenceVar1Exa = gen_exa_names (GradientTurbulenceVar1)&#xa;&#xa;TurbulenceVar2            = (&#x27;E&#x27;,&#x27;TurbulenceVar2&#x27;)&#xa;TurbulenceVar2Exa         = gen_exa_names (TurbulenceVar2)&#xa;GradientTurbulenceVar2    = gen_grad_names(TurbulenceVar2)&#xa;GradientTurbulenceVar2Exa = gen_exa_names (GradientTurbulenceVar2)&#xa;&#xa;Vorticity                 = (&#x27;VORTX&#x27;,&#x27;VORTY&#x27;,&#x27;VORTZ&#x27;,&#x27;Vorticity&#x27;)&#xa;VorticityExa              = gen_exa_names (Vorticity)&#xa;&#xa;for v in varT:&#xa;    if v not in varP:&#xa;        continue&#xa;&#xa;    # Mesh velocity&#xa;    if check_var(v,MeshVelocity): create_vec(*MeshVelocity)&#xa;&#xa;    # Reaction force&#xa;    elif check_var(v,ReactionForce): create_vec(*ReactionForce)&#xa;    # Normal heat flux&#xa;    elif check_var(v,NormalHeatFlux): rename_var(*NormalHeatFlux)&#xa;&#xa;    # Density&#xa;    elif check_var(v,Density): rename_var(*Density)&#xa;    # Speed of sound&#xa;    elif check_var(v,SpeedSound): rename_var(*SpeedSound)&#xa;&#xa;    # Velocity&#xa;    elif check_var(v,Velocity):    create_vec(*Velocity)&#xa;    elif check_var(v,VelocityExa): create_vec(*VelocityExa)&#xa;    # Velocity gradient&#xa;    elif check_var(v,GradientVelocity):    create_mat(*GradientVelocity)&#xa;    elif check_var(v,GradientVelocityExa): create_mat(*GradientVelocityExa)&#xa;    # Velocity hessian&#xa;    elif check_var(v,HessianVelocity):    create_tens3(*HessianVelocity)&#xa;    elif check_var(v,HessianVelocityExa): create_tens3(*HessianVelocityExa)&#xa;&#xa;    # Displacements&#xa;    elif check_var(v,MeshDisp):    create_vec(*MeshDisp)&#xa;    elif check_var(v,MeshDispExa): create_vec(*MeshDispExa)&#xa;    # Displacements gradient&#xa;    elif check_var(v,GradientMeshDisp):    create_mat(*GradientMeshDisp)&#xa;    elif check_var(v,GradientMeshDispExa): create_mat(*GradientMeshDispExa)&#xa;&#xa;    # Pressure&#xa;    elif check_var(v,Pressure):    rename_var(*Pressure)&#xa;    elif check_var(v,PressureExa): rename_var(*PressureExa)&#xa;    # Pressure gradient&#xa;    elif check_var(v,GradientPressure):    create_vec(*GradientPressure)&#xa;    elif check_var(v,GradientPressureExa): create_vec(*GradientPressureExa)&#xa;&#xa;    # Temperature&#xa;    elif check_var(v,Temperature):    rename_var(*Temperature)&#xa;    elif check_var(v,TemperatureExa): rename_var(*TemperatureExa)&#xa;    # Temperature gradient&#xa;    elif check_var(v,GradientTemperature):    create_vec(*GradientTemperature)&#xa;    elif check_var(v,GradientTemperatureExa): create_vec(*GradientTemperatureExa)&#xa;&#xa;    # TurbulenceVar1 (Turbulent Kinetic Energy)&#xa;    elif check_var(v,TurbulenceVar1):    rename_var(*TurbulenceVar1)&#xa;    elif check_var(v,TurbulenceVar1Exa): rename_var(*TurbulenceVar1Exa)&#xa;    # TurbulenceVar1 gradient&#xa;    elif check_var(v,GradientTurbulenceVar1):    create_vec(*GradientTurbulenceVar1)&#xa;    elif check_var(v,GradientTurbulenceVar1Exa): create_vec(*GradientTurbulenceVar1Exa)&#xa;&#xa;    # TurbulenceVar1 (Turbulent Kinetic Energy)&#xa;    elif check_var(v,TurbulenceVar1):    rename_var(*TurbulenceVar1)&#xa;    elif check_var(v,TurbulenceVar1Exa): rename_var(*TurbulenceVar1Exa)&#xa;    # TurbulenceVar1 gradient&#xa;    elif check_var(v,GradientTurbulenceVar1):    create_vec(*GradientTurbulenceVar1)&#xa;    elif check_var(v,GradientTurbulenceVar1Exa): create_vec(*GradientTurbulenceVar1Exa)&#xa;&#xa;    # TurbulenceVar2 (epsilon, omega, ...)&#xa;    elif check_var(v,TurbulenceVar2):    rename_var(*TurbulenceVar2)&#xa;    elif check_var(v,TurbulenceVar2Exa): rename_var(*TurbulenceVar2Exa)&#xa;    # TurbulenceVar2 gradient&#xa;    elif check_var(v,GradientTurbulenceVar2):    create_vec(*GradientTurbulenceVar2)&#xa;    elif check_var(v,GradientTurbulenceVar2Exa): create_vec(*GradientTurbulenceVar2Exa)&#xa;&#xa;    # Vorticity&#xa;    elif check_var(v,Vorticity):    create_vec(*Vorticity)&#xa;    elif check_var(v,VorticityExa): create_vec(*VorticityExa)&#xa;&#xa;for v in varP:&#xa;    o.PointData.VTKObject.AddArray(i.PointData[v].VTKObject)&#xa;&#xa;for v in varC:&#xa;    o.CellData.VTKObject.AddArray(i.CellData[v].VTKObject)"/>
        </Property>
        <Property name="TimestepValues" id="18114.TimestepValues"/>
        <Property name="UpdateExtentScript" id="18114.UpdateExtentScript" number_of_elements="1">
          <Element index="0" value=""/>
        </Property>
      </Proxy>
      <ExposedProperties>
        <Property name="Input" proxy_name="ProgrammableFilter1" exposed_name="Input"/>
        <Property name="Script" proxy_name="ProgrammableFilter1" exposed_name="Script"/>
      </ExposedProperties>
      <OutputPort name="Output" proxy="ProgrammableFilter1" port_index="0"/>
      <Hints>
        <ShowInMenu/>
      </Hints>
    </CompoundSourceProxy>
  </CustomProxyDefinition>
</CustomFilterDefinitions>
